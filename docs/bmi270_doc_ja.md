# BMI270 IMU SPI接続ガイド：マイコンによる起動、初期化、データ読み取り

## 1.0 はじめに：BMI270の概要と本ガイドの目的

### 1.1 BMI270の主要機能の紹介

Bosch Sensortec社のBMI270は、単なる加速度センサーやジャイロスコープの集合体ではありません。インテリジェントなオンチップ機能を搭載した、高性能な6軸慣性計測ユニット（IMU）です。ホストとなるマイクロコントローラーの負荷を軽減しながら、高精度なモーション検知を実現できるため、特にウェアラブルデバイスやバッテリー駆動のIoT機器など、リソースに制約のある組み込みシステムにおいて絶大な価値を発揮します。本セクションでは、BMI270が提供する主要な技術的特徴を解説します。

- **6軸センサー**: 3軸加速度センサーと3軸ジャイロスコープを一つのコンパクトなパッケージに統合しています。これにより、デバイスの直線的な動き（加速度）と回転運動（角速度）を同時に、かつ同期して計測することが可能です。これらのデータは、あらゆるモーションベースのアプリケーションにおける姿勢推定（Orientation Estimation）の基礎となります。
- **低消費電力**: 加速度センサーとジャイロスコープの両方をノーマルモードで動作させた際の標準的な消費電流は、わずか685 µAです。この極めて低い消費電力は、バッテリー寿命が製品競争力を直接左右するウェアラブルデバイスやヒアラブルデバイスにおいて、大きなアドバンテージとなります。
- **オンチップFIFO**: 2 KBの大容量FIFO（First-In, First-Out）バッファを内蔵しています。これにより、マイクロコントローラーはセンサーデータをリアルタイムでポーリングし続ける必要がなくなります。一定量のデータをFIFOに蓄積してから一括で読み出すことで、マイクロコントローラーをスリープ状態に保つ時間を最大化し、システム全体の消費電力を劇的に削減できます。また、高速なデータサンプリング時においても、データの取りこぼしを防ぎます。
- **インテリジェント機能**: BMI270は、単にデータを計測するだけでなく、そのデータを内部で処理するインテリジェントな機能を多数搭載しています。例えば、手首装着時のステップカウンター、各種モーション検知（Significant Motion/Any Motion）、アクティビティ認識（静止/歩行/走行）などが挙げられます。これらの機能を活用することで、従来はホストプロセッサが担っていた複雑なアルゴリズム処理をセンサー側でオフロードし、システムの設計を簡素化できます。

### 1.2 本ガイドの対象読者とゴール

本ガイドは、BMI270を**SPI（Serial Peripheral Interface）**経由でマイクロコントローラーに接続し、基本的なセンサーデータの読み取りを行うことを目指す、すべての組み込みシステム開発者を対象としています。

本ガイドのゴールは、電源投入から安定したデータ取得までの一連の流れを、具体的な手順と注意点を交えてマスターすることです。最終的には、読者の皆様が自信を持ってBMI270を自身のプロジェクトに組み込めるようになることを目指します。

次のセクションでは、BMI270との全ての通信の基礎となるSPIプロトコルの詳細について解説します。このプロトコルを正確に理解することが、安定したセンサー動作を実現するための第一歩となります。

---

## 2.0 SPI通信プロトコルの基礎

### 2.1 導入：マイコン-BMI270間通信の確立

BMI270の設定変更からデータ読み取りまで、全ての操作はデジタルインターフェースを介して行われます。特にSPIは高速通信が可能であり、多くのマイクロコントローラーでサポートされています。このセクションでは、BMI270とSPI通信を確立するためのプロトコルと物理的な接続、そして具体的な操作シーケンスについて解説します。これらのルールを正確に理解し実装することが、信頼性の高いデータ取得に不可欠です。

BMI270は電源投入後、デフォルトではI²Cモードで起動しますが、簡単な操作でSPIモードに切り替えることができます。

1. **電源投入後のCSBピン操作**: 最も一般的で確実な方法です。BMI270のインターフェースは、電源投入直後はデフォルトでI²Cモードに設定されています。初回のダミーリードを実行することが、CSBピンに必要な立ち上がりエッジ（Low→High）を提供し、インターフェースを確実にSPIモードに切り替えるための標準的な手法です。 この操作（例：CHIP_IDレジスタ0x00の読み取り）を省略すると、センサーはSPIコマンドに応答しません。
2. **永続的なSPIモード設定**: NV_CONFレジスタ（アドレス0x70）のspi_enビットを1に設定し、不揮発性メモリ（NVM）に書き込むことで、電源投入のたびにCSBピンを操作することなく、永続的にSPIモードで起動させることが可能です。

### 2.2 SPIのモードと物理接続

BMI270とマイクロコントローラーをSPIで接続する際の主要な仕様は以下の通りです。

- **対応モード**: SPI通信には複数のモード（クロック極性CPOLとクロック位相CPHAの組み合わせ）が存在しますが、BMI270は以下の2つのモードに対応しています。
  - モード '00' (CPOL=0, CPHA=0)
  - モード '11' (CPOL=1, CPHA=1)

  マイクロコントローラー側のSPI設定を、いずれかに合わせる必要があります。

- **4線式と3線式**:
  - **4線式（デフォルト）**: CSB（チップセレクト）、SCx（クロック）、SDx（マスターからの入力）、SDO（センサーからの出力）の4本の信号線を使用します。
  - **3線式**: IF_CONFレジスタ（アドレス0x6B）のspi3ビットを1に設定することで、3線式モードに切り替えることができます。このモードでは、データ線がSDxピンに集約され、双方向通信に使用されます。

| インターフェース | BMI270 ピン | 説明 |
|--------------|-------------|------|
| **4-Wire SPI** | CSB | チップセレクト |
| | SCx | シリアルクロック |
| | SDx | シリアルデータ入力 (SDI) |
| | SDO | シリアルデータ出力 (SDO) |
| **3-Wire SPI** | CSB | チップセレクト |
| | SCx | シリアルクロック |
| | SDx | シリアルデータ I/O (SDA) |

### 2.3 読み取り操作（Read Operation）

レジスタから1バイトのデータを読み取る際のSPI通信シーケンスは、以下のステップで構成されます。特に、BMI270の仕様としてダミーバイトの存在に注意が必要です。

1. マスター（マイコン）がCSBをLowにし、通信を開始します。
2. マスターは、SDx（SDI）ピンから8ビットのコマンドを送信します。このコマンドは、読み取りビット(R/W=1)と7ビットのレジスタアドレスで構成されます。
3. マスターはクロックを送信し続け、SDOピンから最初のダミーバイトを受信します。このダミーバイトは無効なデータであり、必ず破棄する必要があります。
4. マスターはさらに8クロックを送信し、SDOピンから目的のレジスタデータ（2バイト目）を受信します。
5. マスターがCSBをHighに戻し、通信を終了します。

**重要**: **「BMI270のSPI読み取りでは、必ず1バイトのダミーリードが発生する」**というルールは、ドライバーを実装する上で最も重要なポイントの一つです。これを考慮しないと、データが1バイトずれてしまい、正常な値を読み取ることができません。これは実装時に見落とされがちな、よくある失敗点です。

### 2.4 書き込み操作（Write Operation）

レジスタに1バイトのデータを書き込む際のSPI通信シーケンスは、読み取り操作よりもシンプルです。

1. マスター（マイコン）がCSBをLowにし、通信を開始します。
2. マスターは、SDx（SDI）ピンから8ビットのコマンドを送信します。このコマンドは、書き込みビット(R/W=0)と7ビットのレジスタアドレスで構成されます。
3. マスターは続けて、SDx（SDI）ピンから書き込みたい8ビットのデータを送信します。
4. マスターがCSBをHighに戻し、通信を終了します。

### 2.5 通信タイミングに関する重要事項

信頼性の高い通信を実現するためには、以下のタイミング要件を遵守する必要があります。

- **最大クロック周波数**: I/O電源電圧（VDDIO）が1.62V以上の場合、SPIクロックの最大周波数は**10 MHz**です。
- **書き込み後のアイドルタイム**: レジスタへの書き込み操作後、次のアクセスを開始するまでに必要な待機時間（アイドルタイム）は、センサーの動作モードによって大きく異なります。この遅延の遵守は非常に重要です。この待機時間を無視すると、書き込みが正しく反映されない可能性があります。
  - **通常モード (Normal mode)**: 少なくとも**2 µs** (t_IDLE_wr_act) の待機時間が必要です。
  - **サスペンド/低電力モード (Suspend/Low-power mode)**: 少なくとも**450 µs** (t_IDLE_wacc_sum) の待機時間が必要です。この時間は通常モードに比べて非常に長いため、低電力モードでのレジスタ設定時には特に注意が必要です。

これらのプロトコルとタイミング規約を正確に実装することが、次のステップであるセンサーの初期化シーケンスを成功させるための絶対的な前提条件となります。

---

## 3.0 起動シーケンスと必須の初期化

### 3.1 導入：センサーを動作可能状態にするための鍵

BMI270は、電源を投入しただけではセンサーとして機能しません。センサー内部のインテリジェント機能を司るプロセッサを起動し、Bosch Sensortecが提供する独自のコンフィギュレーションファイルをロードするという、厳密な初期化シーケンスが必要です。このシーケンスを正確に実行することが、BMI270の性能を最大限に引き出すための鍵となります。手順を一つでも誤るとセンサーは正しく動作せず、プロジェクトの遅延に繋がる可能性があるため、慎重な実装が求められます。

### 3.2 詳細な初期化手順

マイクロコントローラーが実行すべき具体的な初期化手順は以下の通りです。レジスタ名、アドレス、書き込み値、そして待機時間を正確に守ってください。

1. **電源投入後の待機**: 電源（VDDおよびVDDIO）が安定した後、レジスタにアクセス可能になるまで**450 µs**以上待機します。この待機は非常に重要です。これを怠ると、センサーが内部的に準備完了状態になる前にコマンドを送信してしまい、初期化に失敗する一般的な原因となります。

2. **SPIインターフェースの確立**: セクション2.1で解説した通り、ダミーのレジスタ読み出し（例：CHIP_IDレジスタ 0x00）を実行し、インターフェースを確実にSPIモードに設定します。

3. **アドバンストパワーセーブの無効化**: PWR_CONFレジスタ（アドレス 0x7C）に 0x00 を書き込み、アドバンストパワーセーブモード（APS）を無効にします。初期化中はセンサー内部のプロセッサがアクティブになるため、この設定が必須です。
   ```c
   write_reg(0x7C, 0x00);
   ```

4. **待機**: レジスタ書き込み後、内部状態が安定するまで**450 µs**以上待機します。この待機時間もクリティカルであり、省略することはできません。

5. **設定ファイルのロード準備**: INIT_CTRLレジスタ（アドレス 0x59）に 0x00 を書き込み、設定ファイルのアップロード準備が整ったことをセンサーに通知します。
   ```c
   write_reg(0x59, 0x00);
   ```

6. **設定ファイルのアップロード**:
   - Bosch Sensortecが提供する公式のコンフィギュレーションファイル（bmi270_config_file、約8KB）を準備します。このファイルは、公式のGitHubリポジトリから入手できます。
     - 参照: https://github.com/BoschSensortec/BMI270-Sensor-API/blob/master/bmi270.c
   - この設定データを、INIT_DATAレジスタ（アドレス 0x5E）に対して、SPIのバースト書き込み機能を使用して一括で送信します。
   - **注記（メモリ制約のあるマイコン向け）**: ホストマイコンのRAMバッファが8KBより小さい場合、設定ファイルを一度に送信できないことがあります。その場合、データをより小さなチャンク（塊）に分割して書き込むことが可能です。各チャンクを書き込む間に、INIT_ADDR_0 (0x5B) と INIT_ADDR_1 (0x5C) レジスタに、次に書き込むデータの開始アドレスを書き込む必要があります。具体的には、書き込んだチャンクのバイト数 ÷ 2 だけアドレスをインクリメントします。

7. **設定ファイルのロード完了**: アップロードが完了したら、INIT_CTRLレジスタ（アドレス 0x59）に 0x01 を書き込み、初期化プロセスの完了をセンサーに伝えます。
   ```c
   write_reg(0x59, 0x01);
   ```

### 3.3 初期化完了の確認方法

初期化シーケンスが正しく完了したかを確認することは、その後の動作の信頼性を保証する上で非常に重要です。以下の手順で確認を行ってください。

- INIT_CTRLレジスタに0x01を書き込んだ後、INTERNAL_STATUSレジスタ（アドレス 0x21）を定期的に読み出し（ポーリング）します。
- このレジスタの下位4ビットで構成されるmessageフィールドの値が 0b0001 (0x01) になるのを待ちます。この値は「ASIC initialized」を意味します。
- この確認プロセスには、最大で**20 ms**かかる可能性があります。
- もし0x01以外の値が返された場合（例：0x02 "Initialization error"）、初期化シーケンスに何らかの問題があったことを示します。その場合は、待機時間や書き込み手順に誤りがないか再度確認してください。

この初期化プロセスが成功すると、BMI270は「コンフィギュレーションモード」に移行します。この状態になって初めて、センサーの有効化やデータレートの設定など、次のステップに進む準備が整います。

---

## 4.0 センサーデータの読み取り

### 4.1 導入：初期化後のデータ取得準備

厳密な初期化シーケンスが完了し、BMI270は設定を受け付ける「コンフィギュレーションモード」に入りました。しかし、この段階ではまだセンサーはデータを生成していません。次のステップとして、目的のデータを取得するために、加速度センサーとジャイロスコープを個別に有効化し、それぞれの動作モードや出力データレート（ODR）を設定する必要があります。この設定は、アプリケーションが要求するデータの更新頻度と、システムの消費電力とのトレードオフを決定する重要なプロセスです。

### 4.2 センサーの有効化と基本設定

加速度センサーとジャイロスコープを有効化し、基本的な設定を行う手順は以下の通りです。

#### センサーの有効化

PWR_CTRLレジスタ（アドレス 0x7D）を使用して、各センサーの電源を個別に制御します。

- 加速度センサーを有効にするには、acc_enビット（ビット2）を1にします。
- ジャイロスコープを有効にするには、gyr_enビット（ビット1）を1にします。
- 温度センサーを有効にするには、temp_enビット（ビット3）を1にします。

#### 動作モードとデータレートの設定

センサーの性能（フィルター特性）と出力データレート（ODR）は、それぞれ専用のコンフィギュレーションレジスタで設定します。

- **加速度センサー**: ACC_CONFレジスタ（アドレス 0x40）を使用します。
  - acc_odrフィールド（下位4ビット）でODR（例：100Hzの場合は0x08）を設定します。
  - acc_filter_perfビット（ビット7）でフィルター性能（1=Performance, 0=Power optimized）を設定します。

- **ジャイロスコープ**: GYR_CONFレジスタ（アドレス 0x42）を使用します。
  - gyr_odrフィールド（下位4ビット）でODR（例：200Hzの場合は0x09）を設定します。
  - gyr_filter_perfビット（ビット7）でフィルター性能を設定します。

#### 設定例

加速度センサーを100Hz、ジャイロスコープを200Hzの「ノーマルモード」で動作させる場合、以下の値を書き込みます。

```c
// 1. 加速度、ジャイロ、温度センサーを有効化
write_reg(0x7D, 0x0E);  // PWR_CTRL: 0b00001110

// 2. 加速度センサー設定（100Hz, Performance mode）
write_reg(0x40, 0xA8);  // ACC_CONF

// 3. ジャイロスコープ設定（200Hz, Performance mode）
write_reg(0x42, 0xA9);  // GYR_CONF
```

### 4.3 ダイレクトレジスタ読み取り

センサーを有効化し設定が完了すると、データレジスタから直接センサー値を読み取ることができます。

#### データレジスタのアドレス

各軸のデータは16ビット（2バイト）で格納されています。

- **加速度データ (X, Y, Z)**: DATA_8 (0x0C) から DATA_13 (0x11)
- **ジャイロスコープデータ (X, Y, Z)**: DATA_14 (0x12) から DATA_19 (0x17)

#### データ形式

データは16ビットの2の補数表現です。2つの8ビットレジスタ（LSB: 下位バイト, MSB: 上位バイト）から読み出した後、16ビットの符号付き整数に結合して使用します。

#### シャドウイング手順の重要性

データの完全性を保証するため、BMI270には「シャドウイング」と呼ばれる重要な仕組みが備わっています。マルチバイトのデータを読み取っている最中に値が更新されてしまい、上位バイトと下位バイトで異なるサンプル時点のデータが混在する（データが破損する）ことを防ぎます。

**このルールは非常にシンプルです。各軸のデータは、必ずLSB（下位バイト）のレジスタから読み取ってください。** LSBレジスタが読み取られると、その瞬間に対応するMSB（上位バイト）レジスタの値が内部的にロック（シャドウイング）されます。これにより、次にMSBレジスタを読み取る際には、LSBと同じサンプル時点の値が保証されます。

ダイレクトレジスタ読み取りは最もシンプルで直感的なデータ取得方法ですが、高い頻度でデータを読み取る場合、マイクロコントローラーの処理負荷が増大します。より効率的なデータ収集方法として、次章で解説するFIFOの活用が推奨されます。

---

## 5.0 FIFOを利用した高速データ読み取り

### 5.1 導入：FIFOの価値と利用シナリオ

FIFO（First-In, First-Out）バッファは、BMI270が持つ最も強力な機能の一つです。これを利用することで、マイクロコントローラーの負荷を劇的に削減しつつ、高速かつ欠損のないデータサンプリングが可能になります。FIFOは、センサーが取得したデータを一時的に蓄積するオンチップメモリです。マイクロコントローラーは、常にセンサーを監視する代わりに、FIFOにデータが溜まるのを待ち、必要な時に一括でデータを読み出すことができます。

このアプローチは、特に以下のようなシナリオで絶大な価値を発揮します。

- **高ODR（Output Data Rate）でのデータ収集**: 数百Hz以上の高速サンプリングを行う際、ポーリングではデータの取りこぼしが発生しがちですが、FIFOを使えば確実にデータをキャプチャできます。
- **低消費電力アプリケーション**: マイクロコントローラーを大半の時間スリープさせ、FIFOの割り込み（ウォーターマークなど）をトリガーとして短時間だけ起動させることができます。これにより、システム全体の平均消費電力を大幅に削減できます。

### 5.2 FIFOの有効化と設定

FIFOを利用するには、どのセンサーデータをFIFOに格納するか、またFIFOが満杯になったときにどう振る舞うかを設定する必要があります。

#### センサーデータのFIFO有効化

FIFO_CONFIG_1レジスタ（アドレス 0x49）を使用して、FIFOに格納するデータソースを選択します。

- 加速度データを格納する場合: fifo_acc_enビット（ビット6）を1に設定します。
- ジャイロスコープデータを格納する場合: fifo_gyr_enビット（ビット7）を1に設定します。

#### FIFOモードの設定

**ヘッダーモード / ヘッダーレスモード**: FIFO_CONFIG_1レジスタのfifo_header_enビット（ビット4）で切り替えます。ヘッダーモードを有効（1）にすると、各データフレームの先頭に、どのセンサーのデータが含まれているかなどの情報を持つヘッダーが付加されます。これにより、複数のセンサーデータを異なるレートでサンプリングしている場合でも、データを柔軟に解析できます。

**FIFO満杯時の動作**: FIFO_CONFIG_0レジスタ（アドレス 0x48）のfifo_stop_on_fullビット（ビット0）で、FIFOが満杯になった際の挙動を選択します。

- `0` (fifo_stop_on_full = 0) はストリーミングモードに対応します。最も古いデータから上書きされ、常に最新のデータが保持されます。
- `1` (fifo_stop_on_full = 1) はFIFOモードに対応します。FIFOが満杯になると、新しいデータの書き込みが停止され、データが破棄されます。

### 5.3 FIFOデータの読み出し手順

FIFOに蓄積されたデータをマイクロコントローラーが読み出す手順は、以下の通りです。

1. **FIFOデータ量の確認**: まず、FIFO_LENGTH_0（アドレス 0x24）とFIFO_LENGTH_1（アドレス 0x25）の2つのレジスタを読み出し、現在FIFOに溜まっているデータの総バイト数を確認します。

2. **バーストリードの実行**: ステップ1で確認したバイト数だけ、FIFO_DATAレジスタ（アドレス 0x26）からSPIのバースト読み取りを実行します。

3. **データの解析**: 読み出した一連のバイト列を、設定したフレーム構造に従って解析します。ヘッダーモード（fifo_header_en=1）の場合、バイトストリームは「フレーム」で構成されており、各センサーデータペイロードの前には1バイトのヘッダーが付加されます。加速度とジャイロのODRが異なる場合など、このヘッダーを解析してフレームの内容（どのセンサーデータが含まれているか）を特定することが、正確なデータ抽出に不可欠です。各フレームから加速度やジャイロのデータを抽出し、16ビットのセンサー値に変換します。

### 5.4 高度な利用法：低電力モードでのFIFO活用

FIFOの真価は、低消費電力アプリケーションで発揮されます。fifo_self_wakeup機能を利用することで、システムの消費電力を極限まで抑えることが可能です。この機能の挙動は、PWR_CONFレジスタ（アドレス 0x7C）のfifo_self_wakeupビット（ビット1）の設定によって大きく変わるため、正確な理解が重要です。

- **PWR_CONF.fifo_self_wakeup = 0b0 の場合**: この設定では、FIFO割り込み（ウォーターマークまたは満杯）が発生しても、センサーは低電力モード（アドバンストパワーセーブが有効な状態）を維持します。FIFOデータを読み出すためには、ホストマイコンがまずアドバンストパワーセーブモードを明示的に無効化（PWR_CONF.adv_power_save = 0b0）し、450 µs待機してからFIFOにアクセスする必要があります。

- **PWR_CONF.fifo_self_wakeup = 0b1 の場合 (最大電力効率)**: こちらが、真の低電力FIFO運用のための設定です。FIFO割り込みが発生すると、センサーは一時的にホストマイコンからのFIFO読み出しを受け付けられる状態になります。これにより、マイコンはスリープ状態から復帰し、アドバンストパワーセーブを無効化することなく、単一のバースト読み取りでFIFOデータを一括取得できます。データ取得後、マイコンは即座にスリープに戻ることができ、システムの平均消費電力を劇的に削減することが可能になります。この挙動の違いを理解することが、低消費電力設計を成功させる鍵となります。

---

## まとめ

本ガイドで解説した手順——信頼性の高いSPI通信の確立、厳密な初期化シーケンスの実行、そして目的に応じたデータ読み取り方法（ダイレクトリードまたはFIFO）の選択——をマスターすることで、BMI270の持つ高度な性能を最大限に引き出すことができるでしょう。
