# BMI270 IMU SPI接続ガイド：マイコンによる起動、初期化、データ読み取り

## 1.0 はじめに：BMI270の概要と本ガイドの目的

### 1.1 BMI270の主要機能の紹介

Bosch Sensortec社のBMI270は、単なる加速度センサーやジャイロスコープの集合体ではありません。インテリジェントなオンチップ機能を搭載した、高性能な6軸慣性計測ユニット（IMU）です。ホストとなるマイクロコントローラーの負荷を軽減しながら、高精度なモーション検知を実現できるため、特にウェアラブルデバイスやバッテリー駆動のIoT機器など、リソースに制約のある組み込みシステムにおいて絶大な価値を発揮します。本セクションでは、BMI270が提供する主要な技術的特徴を解説します。

- **6軸センサー**: 3軸加速度センサーと3軸ジャイロスコープを一つのコンパクトなパッケージに統合しています。これにより、デバイスの直線的な動き（加速度）と回転運動（角速度）を同時に、かつ同期して計測することが可能です。これらのデータは、あらゆるモーションベースのアプリケーションにおける姿勢推定（Orientation Estimation）の基礎となります。
- **低消費電力**: 加速度センサーとジャイロスコープの両方をノーマルモードで動作させた際の標準的な消費電流は、わずか685 µAです。この極めて低い消費電力は、バッテリー寿命が製品競争力を直接左右するウェアラブルデバイスやヒアラブルデバイスにおいて、大きなアドバンテージとなります。
- **オンチップFIFO**: 2 KBの大容量FIFO（First-In, First-Out）バッファを内蔵しています。これにより、マイクロコントローラーはセンサーデータをリアルタイムでポーリングし続ける必要がなくなります。一定量のデータをFIFOに蓄積してから一括で読み出すことで、マイクロコントローラーをスリープ状態に保つ時間を最大化し、システム全体の消費電力を劇的に削減できます。また、高速なデータサンプリング時においても、データの取りこぼしを防ぎます。
- **インテリジェント機能**: BMI270は、単にデータを計測するだけでなく、そのデータを内部で処理するインテリジェントな機能を多数搭載しています。例えば、手首装着時のステップカウンター、各種モーション検知（Significant Motion/Any Motion）、アクティビティ認識（静止/歩行/走行）などが挙げられます。これらの機能を活用することで、従来はホストプロセッサが担っていた複雑なアルゴリズム処理をセンサー側でオフロードし、システムの設計を簡素化できます。

### 1.2 本ガイドの対象読者とゴール

本ガイドは、BMI270を**SPI（Serial Peripheral Interface）**経由でマイクロコントローラーに接続し、基本的なセンサーデータの読み取りを行うことを目指す、すべての組み込みシステム開発者を対象としています。

本ガイドのゴールは、電源投入から安定したデータ取得までの一連の流れを、具体的な手順と注意点を交えてマスターすることです。最終的には、読者の皆様が自信を持ってBMI270を自身のプロジェクトに組み込めるようになることを目指します。

次のセクションでは、BMI270との全ての通信の基礎となるSPIプロトコルの詳細について解説します。このプロトコルを正確に理解することが、安定したセンサー動作を実現するための第一歩となります。

---

## 2.0 SPI通信プロトコルの基礎

### 2.1 導入：マイコン-BMI270間通信の確立

BMI270の設定変更からデータ読み取りまで、全ての操作はデジタルインターフェースを介して行われます。特にSPIは高速通信が可能であり、多くのマイクロコントローラーでサポートされています。このセクションでは、BMI270とSPI通信を確立するためのプロトコルと物理的な接続、そして具体的な操作シーケンスについて解説します。これらのルールを正確に理解し実装することが、信頼性の高いデータ取得に不可欠です。

BMI270は電源投入後、デフォルトではI²Cモードで起動しますが、簡単な操作でSPIモードに切り替えることができます。

1. **電源投入後のCSBピン操作**: 最も一般的で確実な方法です。BMI270のインターフェースは、電源投入直後はデフォルトでI²Cモードに設定されています。初回のダミーリードを実行することが、CSBピンに必要な立ち上がりエッジ（Low→High）を提供し、インターフェースを確実にSPIモードに切り替えるための標準的な手法です。 この操作（例：CHIP_IDレジスタ0x00の読み取り）を省略すると、センサーはSPIコマンドに応答しません。
2. **永続的なSPIモード設定**: NV_CONFレジスタ（アドレス0x70）のspi_enビットを1に設定し、不揮発性メモリ（NVM）に書き込むことで、電源投入のたびにCSBピンを操作することなく、永続的にSPIモードで起動させることが可能です。

### 2.2 SPIのモードと物理接続

BMI270とマイクロコントローラーをSPIで接続する際の主要な仕様は以下の通りです。

- **対応モード**: SPI通信には複数のモード（クロック極性CPOLとクロック位相CPHAの組み合わせ）が存在しますが、BMI270は以下の2つのモードに対応しています。
  - モード '00' (CPOL=0, CPHA=0)
  - モード '11' (CPOL=1, CPHA=1)

  マイクロコントローラー側のSPI設定を、いずれかに合わせる必要があります。

- **4線式と3線式**:
  - **4線式（デフォルト）**: CSB（チップセレクト）、SCx（クロック）、SDx（マスターからの入力）、SDO（センサーからの出力）の4本の信号線を使用します。
  - **3線式**: IF_CONFレジスタ（アドレス0x6B）のspi3ビットを1に設定することで、3線式モードに切り替えることができます。このモードでは、データ線がSDxピンに集約され、双方向通信に使用されます。

| インターフェース | BMI270 ピン | 説明 |
|--------------|-------------|------|
| **4-Wire SPI** | CSB | チップセレクト |
| | SCx | シリアルクロック |
| | SDx | シリアルデータ入力 (SDI) |
| | SDO | シリアルデータ出力 (SDO) |
| **3-Wire SPI** | CSB | チップセレクト |
| | SCx | シリアルクロック |
| | SDx | シリアルデータ I/O (SDA) |

### 2.3 読み取り操作（Read Operation）

レジスタから1バイトのデータを読み取る際のSPI通信シーケンスは、以下のステップで構成されます。特に、BMI270の仕様としてダミーバイトの存在に注意が必要です。

1. マスター（マイコン）がCSBをLowにし、通信を開始します。
2. マスターは、SDx（SDI）ピンから8ビットのコマンドを送信します。このコマンドは、読み取りビット(R/W=1)と7ビットのレジスタアドレスで構成されます。
3. マスターはクロックを送信し続け、SDOピンから最初のダミーバイトを受信します。このダミーバイトは無効なデータであり、必ず破棄する必要があります。
4. マスターはさらに8クロックを送信し、SDOピンから目的のレジスタデータ（2バイト目）を受信します。
5. マスターがCSBをHighに戻し、通信を終了します。

**重要**: **「BMI270のSPI読み取りでは、必ず1バイトのダミーリードが発生する」**というルールは、ドライバーを実装する上で最も重要なポイントの一つです。これを考慮しないと、データが1バイトずれてしまい、正常な値を読み取ることができません。これは実装時に見落とされがちな、よくある失敗点です。

### 2.4 書き込み操作（Write Operation）

レジスタに1バイトのデータを書き込む際のSPI通信シーケンスは、読み取り操作よりもシンプルです。

1. マスター（マイコン）がCSBをLowにし、通信を開始します。
2. マスターは、SDx（SDI）ピンから8ビットのコマンドを送信します。このコマンドは、書き込みビット(R/W=0)と7ビットのレジスタアドレスで構成されます。
3. マスターは続けて、SDx（SDI）ピンから書き込みたい8ビットのデータを送信します。
4. マスターがCSBをHighに戻し、通信を終了します。

### 2.5 通信タイミングに関する重要事項

信頼性の高い通信を実現するためには、以下のタイミング要件を遵守する必要があります。

- **最大クロック周波数**: I/O電源電圧（VDDIO）が1.62V以上の場合、SPIクロックの最大周波数は**10 MHz**です。
- **書き込み後のアイドルタイム**: レジスタへの書き込み操作後、次のアクセスを開始するまでに必要な待機時間（アイドルタイム）は、センサーの動作モードによって大きく異なります。この遅延の遵守は非常に重要です。この待機時間を無視すると、書き込みが正しく反映されない可能性があります。
  - **通常モード (Normal mode)**: 少なくとも**2 µs** (t_IDLE_wr_act) の待機時間が必要です。
  - **サスペンド/低電力モード (Suspend/Low-power mode)**: 少なくとも**450 µs** (t_IDLE_wacc_sum) の待機時間が必要です。この時間は通常モードに比べて非常に長いため、低電力モードでのレジスタ設定時には特に注意が必要です。

これらのプロトコルとタイミング規約を正確に実装することが、次のステップであるセンサーの初期化シーケンスを成功させるための絶対的な前提条件となります。

---

## 3.0 起動シーケンスと必須の初期化

### 3.1 導入：センサーを動作可能状態にするための鍵

BMI270は、電源を投入しただけではセンサーとして機能しません。センサー内部のインテリジェント機能を司るプロセッサを起動し、Bosch Sensortecが提供する独自のコンフィギュレーションファイルをロードするという、厳密な初期化シーケンスが必要です。このシーケンスを正確に実行することが、BMI270の性能を最大限に引き出すための鍵となります。手順を一つでも誤るとセンサーは正しく動作せず、プロジェクトの遅延に繋がる可能性があるため、慎重な実装が求められます。

### 3.2 詳細な初期化手順

マイクロコントローラーが実行すべき具体的な初期化手順は以下の通りです。レジスタ名、アドレス、書き込み値、そして待機時間を正確に守ってください。

1. **電源投入後の待機**: 電源（VDDおよびVDDIO）が安定した後、レジスタにアクセス可能になるまで**450 µs**以上待機します。この待機は非常に重要です。これを怠ると、センサーが内部的に準備完了状態になる前にコマンドを送信してしまい、初期化に失敗する一般的な原因となります。

2. **SPIインターフェースの確立**: セクション2.1で解説した通り、ダミーのレジスタ読み出し（例：CHIP_IDレジスタ 0x00）を実行し、インターフェースを確実にSPIモードに設定します。

3. **アドバンストパワーセーブの無効化**: PWR_CONFレジスタ（アドレス 0x7C）に 0x00 を書き込み、アドバンストパワーセーブモード（APS）を無効にします。初期化中はセンサー内部のプロセッサがアクティブになるため、この設定が必須です。
   ```c
   write_reg(0x7C, 0x00);
   ```

4. **待機**: レジスタ書き込み後、内部状態が安定するまで**450 µs**以上待機します。この待機時間もクリティカルであり、省略することはできません。

5. **設定ファイルのロード準備**: INIT_CTRLレジスタ（アドレス 0x59）に 0x00 を書き込み、設定ファイルのアップロード準備が整ったことをセンサーに通知します。
   ```c
   write_reg(0x59, 0x00);
   ```

6. **設定ファイルのアップロード**:
   - Bosch Sensortecが提供する公式のコンフィギュレーションファイル（bmi270_config_file、約8KB）を準備します。このファイルは、公式のGitHubリポジトリから入手できます。
     - 参照: https://github.com/BoschSensortec/BMI270-Sensor-API/blob/master/bmi270.c
   - この設定データを、INIT_DATAレジスタ（アドレス 0x5E）に対して、SPIのバースト書き込み機能を使用して一括で送信します。
   - **注記（メモリ制約のあるマイコン向け）**: ホストマイコンのRAMバッファが8KBより小さい場合、設定ファイルを一度に送信できないことがあります。その場合、データをより小さなチャンク（塊）に分割して書き込むことが可能です。各チャンクを書き込む間に、INIT_ADDR_0 (0x5B) と INIT_ADDR_1 (0x5C) レジスタに、次に書き込むデータの開始アドレスを書き込む必要があります。具体的には、書き込んだチャンクのバイト数 ÷ 2 だけアドレスをインクリメントします。

7. **設定ファイルのロード完了**: アップロードが完了したら、INIT_CTRLレジスタ（アドレス 0x59）に 0x01 を書き込み、初期化プロセスの完了をセンサーに伝えます。
   ```c
   write_reg(0x59, 0x01);
   ```

### 3.3 初期化完了の確認方法

初期化シーケンスが正しく完了したかを確認することは、その後の動作の信頼性を保証する上で非常に重要です。以下の手順で確認を行ってください。

- INIT_CTRLレジスタに0x01を書き込んだ後、INTERNAL_STATUSレジスタ（アドレス 0x21）を定期的に読み出し（ポーリング）します。
- このレジスタの下位4ビットで構成されるmessageフィールドの値が 0b0001 (0x01) になるのを待ちます。この値は「ASIC initialized」を意味します。
- この確認プロセスには、最大で**20 ms**かかる可能性があります。
- もし0x01以外の値が返された場合（例：0x02 "Initialization error"）、初期化シーケンスに何らかの問題があったことを示します。その場合は、待機時間や書き込み手順に誤りがないか再度確認してください。

この初期化プロセスが成功すると、BMI270は「コンフィギュレーションモード」に移行します。この状態になって初めて、センサーの有効化やデータレートの設定など、次のステップに進む準備が整います。

---

## 4.0 センサーデータの読み取り

### 4.1 導入：初期化後のデータ取得準備

厳密な初期化シーケンスが完了し、BMI270は設定を受け付ける「コンフィギュレーションモード」に入りました。しかし、この段階ではまだセンサーはデータを生成していません。次のステップとして、目的のデータを取得するために、加速度センサーとジャイロスコープを個別に有効化し、それぞれの動作モードや出力データレート（ODR）を設定する必要があります。この設定は、アプリケーションが要求するデータの更新頻度と、システムの消費電力とのトレードオフを決定する重要なプロセスです。

### 4.2 センサーの有効化と基本設定

加速度センサーとジャイロスコープを有効化し、基本的な設定を行う手順は以下の通りです。

#### センサーの有効化

PWR_CTRLレジスタ（アドレス 0x7D）を使用して、各センサーの電源を個別に制御します。

- 加速度センサーを有効にするには、acc_enビット（ビット2）を1にします。
- ジャイロスコープを有効にするには、gyr_enビット（ビット1）を1にします。
- 温度センサーを有効にするには、temp_enビット（ビット3）を1にします。

#### 動作モードとデータレートの設定

センサーの性能（フィルター特性）と出力データレート（ODR）は、それぞれ専用のコンフィギュレーションレジスタで設定します。

##### 加速度センサーの設定（ACC_CONF: 0x40）

**ACC_CONFレジスタのビット構成**:
- **bits 3:0** (acc_odr): 出力データレート（ODR）
- **bit 7** (acc_filter_perf): フィルター性能モード
  - 0 = Power optimized（省電力優先）
  - 1 = Performance（性能優先、推奨）

**加速度センサーのODR設定値**:

| ODR        | レジスタ値 (bits 3:0) | 備考 |
|------------|----------------------|------|
| 0.78 Hz    | 0x01 | 超低速（特殊用途） |
| 1.5 Hz     | 0x02 | - |
| 3.1 Hz     | 0x03 | - |
| 6.25 Hz    | 0x04 | 低速モニタリング |
| 12.5 Hz    | 0x05 | - |
| 25 Hz      | 0x06 | 低消費電力 |
| 50 Hz      | 0x07 | 標準モニタリング |
| **100 Hz** | **0x08** | **推奨（一般用途）** |
| 200 Hz     | 0x09 | 高速サンプリング |
| 400 Hz     | 0x0A | - |
| 800 Hz     | 0x0B | 非常に高速 |
| 1600 Hz    | 0x0C | 最高速（特殊用途） |

##### ジャイロスコープの設定（GYR_CONF: 0x42）

**GYR_CONFレジスタのビット構成**:
- **bits 3:0** (gyr_odr): 出力データレート（ODR）
- **bit 7** (gyr_filter_perf): フィルター性能モード
  - 0 = Power optimized（省電力優先）
  - 1 = Performance（性能優先、推奨）

**ジャイロスコープのODR設定値**:

| ODR        | レジスタ値 (bits 3:0) | 備考 |
|------------|----------------------|------|
| 25 Hz      | 0x06 | 低速モニタリング |
| 50 Hz      | 0x07 | - |
| 100 Hz     | 0x08 | 標準モニタリング |
| **200 Hz** | **0x09** | **推奨（一般用途）** |
| 400 Hz     | 0x0A | 高速サンプリング |
| 800 Hz     | 0x0B | 非常に高速 |
| 1600 Hz    | 0x0C | - |
| 3200 Hz    | 0x0D | 最高速（特殊用途） |

##### フィルター性能モードの選択

- **Performance mode (bit 7 = 1)**: より正確なフィルタリング、ノイズが少ない（推奨）
- **Power optimized mode (bit 7 = 0)**: 消費電力を最小化、若干のノイズ増加

一般的なアプリケーションでは **Performance mode** を推奨します。

##### ACC_CONF と GYR_CONF の値の計算

レジスタ値は以下のように計算します：

```c
uint8_t acc_conf = odr_value | (filter_perf << 7);
uint8_t gyr_conf = odr_value | (filter_perf << 7);
```

例:
- 100Hz, Performance mode: `0x08 | 0x80 = 0x88` (0b10001000)
- 200Hz, Performance mode: `0x09 | 0x80 = 0x89` (0b10001001)
- 100Hz, Power optimized: `0x08 | 0x00 = 0x08` (0b00001000)

#### 設定例

加速度センサーを100Hz、ジャイロスコープを200Hzの「Performance モード」で動作させる場合、以下の値を書き込みます。

```c
// 1. 加速度、ジャイロ、温度センサーを有効化
write_reg(0x7D, 0x0E);  // PWR_CTRL: 0b00001110

// 2. 加速度センサー設定（100Hz, Performance mode）
write_reg(0x40, 0x88);  // ACC_CONF: ODR=100Hz (0x08), filter_perf=1 (0x80)

// 3. ジャイロスコープ設定（200Hz, Performance mode）
write_reg(0x42, 0x89);  // GYR_CONF: ODR=200Hz (0x09), filter_perf=1 (0x80)
```

#### ODR選択の指針

- **加速度センサー**:
  - 一般的なモーションセンシング: 100Hz（推奨）
  - 高速動作解析: 400Hz～800Hz
  - 低消費電力モード: 25Hz～50Hz

- **ジャイロスコープ**:
  - 一般的な姿勢推定: 200Hz（推奨）
  - 高精度姿勢制御: 400Hz～800Hz
  - 低消費電力モード: 100Hz

**重要**: 加速度とジャイロのODRを異なる値に設定することも可能です。ただし、FIFO使用時はヘッダーモードを有効にして、データフレームを正しく識別する必要があります。

### 4.3 ダイレクトレジスタ読み取り

センサーを有効化し設定が完了すると、データレジスタから直接センサー値を読み取ることができます。

#### データレジスタのアドレス

各軸のデータは16ビット（2バイト）で格納されています。

- **加速度データ (X, Y, Z)**: DATA_8 (0x0C) から DATA_13 (0x11)
- **ジャイロスコープデータ (X, Y, Z)**: DATA_14 (0x12) から DATA_19 (0x17)

#### データ形式

データは16ビットの2の補数表現です。2つの8ビットレジスタ（LSB: 下位バイト, MSB: 上位バイト）から読み出した後、16ビットの符号付き整数に結合して使用します。

#### シャドウイング手順の重要性

データの完全性を保証するため、BMI270には「シャドウイング」と呼ばれる重要な仕組みが備わっています。マルチバイトのデータを読み取っている最中に値が更新されてしまい、上位バイトと下位バイトで異なるサンプル時点のデータが混在する（データが破損する）ことを防ぎます。

**このルールは非常にシンプルです。各軸のデータは、必ずLSB（下位バイト）のレジスタから読み取ってください。** LSBレジスタが読み取られると、その瞬間に対応するMSB（上位バイト）レジスタの値が内部的にロック（シャドウイング）されます。これにより、次にMSBレジスタを読み取る際には、LSBと同じサンプル時点の値が保証されます。

ダイレクトレジスタ読み取りは最もシンプルで直感的なデータ取得方法ですが、高い頻度でデータを読み取る場合、マイクロコントローラーの処理負荷が増大します。より効率的なデータ収集方法として、次章で解説するFIFOの活用が推奨されます。

### 4.4 レンジ設定とスケール係数

センサーから読み取った16ビットの生データ（LSB: Least Significant Bit）を物理的な単位（加速度は g、角速度は °/s）に変換するには、現在設定されているレンジに応じたスケール係数を使用する必要があります。

#### 加速度センサーのレンジ設定

加速度センサーの測定レンジは、**ACC_RANGE レジスタ（アドレス 0x41）** で設定します。このレジスタの下位2ビット（bits 1:0）がレンジ設定値です。

| レンジ | レジスタ値 (bits 1:0) | スケール係数 | 分解能 |
|--------|----------------------|-------------|--------|
| ±2g    | 0x00 | 16384 LSB/g | 0.061 mg/LSB |
| ±4g    | 0x01 | 8192 LSB/g  | 0.122 mg/LSB |
| ±8g    | 0x02 | 4096 LSB/g  | 0.244 mg/LSB |
| ±16g   | 0x03 | 2048 LSB/g  | 0.488 mg/LSB |

**設定例**:

```c
// ±4g レンジに設定
write_reg(0x41, 0x01);  // ACC_RANGE = 0x01
```

**デフォルト値**: ±2g（レジスタ値 0x00）

#### ジャイロスコープのレンジ設定

ジャイロスコープの測定レンジは、**GYR_RANGE レジスタ（アドレス 0x43）** で設定します。このレジスタの下位3ビット（bits 2:0）がレンジ設定値です。

| レンジ      | レジスタ値 (bits 2:0) | スケール係数        | 分解能 |
|------------|----------------------|---------------------|--------|
| ±125 °/s   | 0x04 | 262.4 LSB/(°/s) | 0.00381 (°/s)/LSB |
| ±250 °/s   | 0x03 | 131.2 LSB/(°/s) | 0.00763 (°/s)/LSB |
| ±500 °/s   | 0x02 | 65.6 LSB/(°/s)  | 0.01526 (°/s)/LSB |
| ±1000 °/s  | 0x01 | 32.8 LSB/(°/s)  | 0.03049 (°/s)/LSB |
| ±2000 °/s  | 0x00 | 16.4 LSB/(°/s)  | 0.06098 (°/s)/LSB |

**設定例**:

```c
// ±1000 °/s レンジに設定
write_reg(0x43, 0x01);  // GYR_RANGE = 0x01
```

**デフォルト値**: ±2000 °/s（レジスタ値 0x00）

#### 生データから物理値への変換

16ビットの2の補数表現で読み取ったセンサー値を物理値に変換する式は以下の通りです：

**加速度の変換**:

```c
float accel_g = (float)raw_value / scale_factor;
```

例（±2g レンジの場合）:

```c
int16_t raw_x = 8192;  // 生データ
float accel_x_g = (float)raw_x / 16384.0f;  // = 0.5g
```

**角速度の変換**:

```c
float gyro_dps = (float)raw_value / scale_factor;
```

例（±2000 °/s レンジの場合）:

```c
int16_t raw_x = 328;  // 生データ
float gyro_x_dps = (float)raw_x / 16.4f;  // = 20.0 °/s
```

#### レンジ選択の指針

- **加速度センサー**:
  - 一般的なモーション検知: ±2g または ±4g（高分解能）
  - 衝撃検知や激しい動き: ±8g または ±16g（広範囲）

- **ジャイロスコープ**:
  - 低速回転の精密測定: ±125 °/s または ±250 °/s（高分解能）
  - 一般的なモーション: ±500 °/s または ±1000 °/s
  - 高速回転: ±2000 °/s（広範囲）

### 4.5 データ読み取りの実装パターン

#### 推奨: バースト読み取り

3軸すべてのデータを読み取る際は、シャドウイング機能を最大限活用するため、**バースト読み取り**を使用することを強く推奨します。

**加速度データのバースト読み取り（6バイト）**:

```c
uint8_t data[6];
// ACC_X_LSB (0x0C) から6バイト連続読み取り
// 順序: ACC_X_LSB, ACC_X_MSB, ACC_Y_LSB, ACC_Y_MSB, ACC_Z_LSB, ACC_Z_MSB
burst_read(0x0C, data, 6);

// データ結合（リトルエンディアン）
int16_t acc_x = (int16_t)((data[1] << 8) | data[0]);
int16_t acc_y = (int16_t)((data[3] << 8) | data[2]);
int16_t acc_z = (int16_t)((data[5] << 8) | data[4]);
```

**ジャイロデータのバースト読み取り（6バイト）**:

```c
uint8_t data[6];
// GYR_X_LSB (0x12) から6バイト連続読み取り
burst_read(0x12, data, 6);

int16_t gyr_x = (int16_t)((data[1] << 8) | data[0]);
int16_t gyr_y = (int16_t)((data[3] << 8) | data[2]);
int16_t gyr_z = (int16_t)((data[5] << 8) | data[4]);
```

#### シャドウイングの確認

- バースト読み取りでは、最初のレジスタ（LSB）を読んだ時点で、対応するすべてのMSBレジスタが内部でロックされます
- これにより、6バイトの読み取り中にデータが更新されても、一貫性のあるスナップショットが保証されます
- **重要**: 必ずLSBレジスタから読み取りを開始してください

#### 完全な読み取り例（加速度 + ジャイロ）

両方のセンサーデータを同時に取得する場合、2回のバースト読み取りを実行します：

```c
// Step 1: 加速度データ読み取り（6バイト）
uint8_t acc_data[6];
burst_read(0x0C, acc_data, 6);
int16_t acc_x = (int16_t)((acc_data[1] << 8) | acc_data[0]);
int16_t acc_y = (int16_t)((acc_data[3] << 8) | acc_data[2]);
int16_t acc_z = (int16_t)((acc_data[5] << 8) | acc_data[4]);

// Step 2: ジャイロデータ読み取り（6バイト）
uint8_t gyr_data[6];
burst_read(0x12, gyr_data, 6);
int16_t gyr_x = (int16_t)((gyr_data[1] << 8) | gyr_data[0]);
int16_t gyr_y = (int16_t)((gyr_data[3] << 8) | gyr_data[2]);
int16_t gyr_z = (int16_t)((gyr_data[5] << 8) | gyr_data[4]);

// Step 3: 物理値への変換（±2g、±2000°/s の場合）
float accel_x_g = (float)acc_x / 16384.0f;
float accel_y_g = (float)acc_y / 16384.0f;
float accel_z_g = (float)acc_z / 16384.0f;

float gyro_x_dps = (float)gyr_x / 16.4f;
float gyro_y_dps = (float)gyr_y / 16.4f;
float gyro_z_dps = (float)gyr_z / 16.4f;
```

### 4.6 温度センサーの読み取り

BMI270には、加速度センサーとジャイロスコープに加えて、**オンチップ温度センサー**が内蔵されています。この温度センサーは、主に加速度・ジャイロデータの温度補正に使用されますが、環境温度のモニタリングにも利用できます。

#### 温度センサーの仕様

| 項目 | 仕様 |
|------|------|
| 測定範囲 | -40°C ～ +85°C |
| 分解能 | 1/512 °C/LSB (約 0.002 °C/LSB) |
| 精度 | ±1°C (典型値) |
| 更新レート | 1.28秒ごと（Performance mode時） |
| データ形式 | 16ビット 2の補数表現 |
| レジスタ形式 | ビッグエンディアン（MSB→LSB） |

**重要**: 温度センサーのデータはビッグエンディアン形式で格納されています。これは、加速度・ジャイロデータのリトルエンディアン形式とは異なるため、実装時に注意が必要です。

#### 温度センサーの有効化

温度センサーは、**PWR_CTRL レジスタ（アドレス 0x7D）** の bit 3（temp_en）で有効化します。

```c
// 加速度、ジャイロ、温度センサーを有効化
uint8_t pwr_ctrl = 0x0E;  // 0b00001110
//                   ||||
//                   |||+--- bit 0: aux_en  = 0 (補助センサー無効)
//                   ||+---- bit 1: gyr_en  = 1 (ジャイロ有効)
//                   |+----- bit 2: acc_en  = 1 (加速度有効)
//                   +------ bit 3: temp_en = 1 (温度センサー有効)
write_reg(0x7D, pwr_ctrl);
```

**注意事項**:
- 温度センサーの出力値を正確に取得するには、ジャイロスコープが Normal mode（gyr_pmu_status=1）で動作している必要があります
- ジャイロスコープが Suspend mode の場合、温度センサーのデータは無効です

#### 温度データレジスタ

温度データは2つのレジスタに格納されています：

| レジスタ名 | アドレス | 内容 |
|-----------|---------|------|
| TEMP_MSB  | 0x22    | 温度データの上位8ビット |
| TEMP_LSB  | 0x23    | 温度データの下位8ビット |

#### 温度データの読み取り

温度データは、2バイトのバースト読み取りで取得します。**重要**: 温度データはビッグエンディアン形式（MSB first）で格納されています。

```c
// TEMP_MSB (0x22) から2バイト連続読み取り
uint8_t temp_data[2];
burst_read(0x22, temp_data, 2);

// ビッグエンディアン形式で結合
int16_t temp_raw = (int16_t)((temp_data[0] << 8) | temp_data[1]);
```

#### 温度値の変換式

16ビットの生データを摂氏温度（°C）に変換する式は以下の通りです：

```c
float temperature_celsius = ((float)temp_raw / 512.0f) + 23.0f;
```

**変換式の構成要素**:
- **分解能**: 512 LSB/°C (= 2^9)
- **オフセット**: 23°C（室温での基準温度）

#### 読み取り例

```c
// 温度データの読み取り
uint8_t temp_data[2];
esp_err_t ret = bmi270_read_burst(dev, 0x22, temp_data, 2);
if (ret != ESP_OK) {
    ESP_LOGE(TAG, "Failed to read temperature");
    return ret;
}

// ビッグエンディアンで結合（加速度/ジャイロとは異なる！）
int16_t temp_raw = (int16_t)((temp_data[0] << 8) | temp_data[1]);

// 物理値への変換
float temperature = ((float)temp_raw / 512.0f) + 23.0f;

printf("Temperature: %.2f °C\n", temperature);
```

#### エンディアン形式の比較

BMI270のデータレジスタは、センサーによってエンディアンが異なります：

| センサー | レジスタ順序 | エンディアン | 結合方法 |
|---------|-------------|------------|---------|
| 加速度   | ACC_X_LSB (0x0C), ACC_X_MSB (0x0D) | リトル | `(MSB << 8) \| LSB` |
| ジャイロ | GYR_X_LSB (0x12), GYR_X_MSB (0x13) | リトル | `(MSB << 8) \| LSB` |
| 温度     | TEMP_MSB (0x22), TEMP_LSB (0x23)   | **ビッグ** | `(MSB << 8) \| LSB` |

**注意**: バースト読み取りの開始アドレスが異なります：
- 加速度/ジャイロ: LSBアドレスから開始（例: 0x0C）
- 温度: MSBアドレスから開始（0x22）

#### 温度センサーの用途

1. **温度補正（Temperature Compensation）**:
   - 加速度・ジャイロのオフセットやゲインは温度によって変化します
   - 温度データを使用して、ソフトウェアで補正計算を行うことができます

2. **環境モニタリング**:
   - デバイスの動作温度を監視し、過熱保護などに利用できます
   - ただし、センサー内部の温度であり、外部環境温度とは異なる可能性があります

3. **データ品質の評価**:
   - 温度が急激に変化している場合、センサーデータの信頼性が低下する可能性があります
   - 温度トレンドを監視することで、データの品質を評価できます

#### トラブルシューティング

**症状**: 温度値が異常（極端に高い/低い、不安定）

**考えられる原因と対策**:

1. **温度センサーが有効化されていない**:
   - PWR_CTRL レジスタの bit 3（temp_en）が 0 になっている
   - 対策: `PWR_CTRL = 0x0E` を設定し、temp_en を 1 にする

2. **ジャイロスコープが Suspend mode**:
   - 温度センサーの出力にはジャイロが Normal mode である必要があります
   - 対策: PWR_CTRL の bit 1（gyr_en）を 1 に設定

3. **エンディアンの誤り**:
   - 加速度/ジャイロと同じリトルエンディアンで読み取っている
   - 対策: 温度はビッグエンディアン（MSB first）で読み取る

4. **変換式の誤り**:
   - スケール係数やオフセットが間違っている
   - 対策: 正しい式 `(temp_raw / 512.0) + 23.0` を使用

#### 正常な温度値の目安

- **室温環境**: 約 20°C ～ 30°C
- **連続動作時**: 約 30°C ～ 40°C（センサー内部の自己発熱）
- **高負荷時**: 約 40°C ～ 60°C（センサー + ホストプロセッサの発熱）

**異常値の例**:
- 85°C 以上: 変換式の誤り、またはエンディアンの誤り
- -30°C 以下（室温環境で）: エンディアンの誤り、または温度センサー未有効化
- 値が頻繁に反転（+85°C ↔ -30°C）: 温度センサーが有効化されておらず、未定義データを読み取っている

---

## 5.0 FIFOを利用した高速データ読み取り

### 5.1 導入：FIFOの価値と利用シナリオ

FIFO（First-In, First-Out）バッファは、BMI270が持つ最も強力な機能の一つです。これを利用することで、マイクロコントローラーの負荷を劇的に削減しつつ、高速かつ欠損のないデータサンプリングが可能になります。FIFOは、センサーが取得したデータを一時的に蓄積するオンチップメモリです。マイクロコントローラーは、常にセンサーを監視する代わりに、FIFOにデータが溜まるのを待ち、必要な時に一括でデータを読み出すことができます。

このアプローチは、特に以下のようなシナリオで絶大な価値を発揮します。

- **高ODR（Output Data Rate）でのデータ収集**: 数百Hz以上の高速サンプリングを行う際、ポーリングではデータの取りこぼしが発生しがちですが、FIFOを使えば確実にデータをキャプチャできます。
- **低消費電力アプリケーション**: マイクロコントローラーを大半の時間スリープさせ、FIFOの割り込み（ウォーターマークなど）をトリガーとして短時間だけ起動させることができます。これにより、システム全体の平均消費電力を大幅に削減できます。

### 5.2 FIFOの有効化と設定

FIFOを利用するには、どのセンサーデータをFIFOに格納するか、またFIFOが満杯になったときにどう振る舞うかを設定する必要があります。

#### センサーデータのFIFO有効化

FIFO_CONFIG_1レジスタ（アドレス 0x49）を使用して、FIFOに格納するデータソースを選択します。

- 加速度データを格納する場合: fifo_acc_enビット（ビット6）を1に設定します。
- ジャイロスコープデータを格納する場合: fifo_gyr_enビット（ビット7）を1に設定します。

#### FIFOモードの設定

**ヘッダーモード / ヘッダーレスモード**: FIFO_CONFIG_1レジスタのfifo_header_enビット（ビット4）で切り替えます。ヘッダーモードを有効（1）にすると、各データフレームの先頭に、どのセンサーのデータが含まれているかなどの情報を持つヘッダーが付加されます。これにより、複数のセンサーデータを異なるレートでサンプリングしている場合でも、データを柔軟に解析できます。

**FIFO満杯時の動作**: FIFO_CONFIG_0レジスタ（アドレス 0x48）のfifo_stop_on_fullビット（ビット0）で、FIFOが満杯になった際の挙動を選択します。

- `0` (fifo_stop_on_full = 0) はストリーミングモードに対応します。最も古いデータから上書きされ、常に最新のデータが保持されます。
- `1` (fifo_stop_on_full = 1) はFIFOモードに対応します。FIFOが満杯になると、新しいデータの書き込みが停止され、データが破棄されます。

### 5.3 FIFOデータの読み出し手順

FIFOに蓄積されたデータをマイクロコントローラーが読み出す手順は、以下の通りです。

1. **FIFOデータ量の確認**: まず、FIFO_LENGTH_0（アドレス 0x24）とFIFO_LENGTH_1（アドレス 0x25）の2つのレジスタを読み出し、現在FIFOに溜まっているデータの総バイト数を確認します。

2. **バーストリードの実行**: ステップ1で確認したバイト数だけ、FIFO_DATAレジスタ（アドレス 0x26）からSPIのバースト読み取りを実行します。

3. **データの解析**: 読み出した一連のバイト列を、設定したフレーム構造に従って解析します。ヘッダーモード（fifo_header_en=1）の場合、バイトストリームは「フレーム」で構成されており、各センサーデータペイロードの前には1バイトのヘッダーが付加されます。加速度とジャイロのODRが異なる場合など、このヘッダーを解析してフレームの内容（どのセンサーデータが含まれているか）を特定することが、正確なデータ抽出に不可欠です。各フレームから加速度やジャイロのデータを抽出し、16ビットのセンサー値に変換します。

### 5.4 高度な利用法：低電力モードでのFIFO活用

FIFOの真価は、低消費電力アプリケーションで発揮されます。fifo_self_wakeup機能を利用することで、システムの消費電力を極限まで抑えることが可能です。この機能の挙動は、PWR_CONFレジスタ（アドレス 0x7C）のfifo_self_wakeupビット（ビット1）の設定によって大きく変わるため、正確な理解が重要です。

- **PWR_CONF.fifo_self_wakeup = 0b0 の場合**: この設定では、FIFO割り込み（ウォーターマークまたは満杯）が発生しても、センサーは低電力モード（アドバンストパワーセーブが有効な状態）を維持します。FIFOデータを読み出すためには、ホストマイコンがまずアドバンストパワーセーブモードを明示的に無効化（PWR_CONF.adv_power_save = 0b0）し、450 µs待機してからFIFOにアクセスする必要があります。

- **PWR_CONF.fifo_self_wakeup = 0b1 の場合 (最大電力効率)**: こちらが、真の低電力FIFO運用のための設定です。FIFO割り込みが発生すると、センサーは一時的にホストマイコンからのFIFO読み出しを受け付けられる状態になります。これにより、マイコンはスリープ状態から復帰し、アドバンストパワーセーブを無効化することなく、単一のバースト読み取りでFIFOデータを一括取得できます。データ取得後、マイコンは即座にスリープに戻ることができ、システムの平均消費電力を劇的に削減することが可能になります。この挙動の違いを理解することが、低消費電力設計を成功させる鍵となります。

---

## まとめ

本ガイドで解説した手順——信頼性の高いSPI通信の確立、厳密な初期化シーケンスの実行、そして目的に応じたデータ読み取り方法（ダイレクトリードまたはFIFO）の選択——をマスターすることで、BMI270の持つ高度な性能を最大限に引き出すことができるでしょう。
